'''
файл моделей(таблиц) базы данных и классов для взаимодействия с ней
'''

from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import UserMixin
from app import login

from abc import ABC, abstractmethod
import psycopg2

class _DataBase():
    '''
    класс описывающий базу даннных
    данный клас будет инкапсулировать в себе все необходимые для подключения к базе
    параметры (при разработке они будут захардкочены, как их прокинуть будет придумано позже)
    будет реализован метод возвращающий connection - объект соединения с базой,
    который как раз таки будет необходим в методах класса Table и его потоммков
    '''
    _db_name = 'messenger'
    _db_user = 'maxti'
    _user_password = '********'
    _db_host = 'localhost'
    _db_port = '5432'

    _connection: psycopg2 = None

    @classmethod
    def _connect(cls) -> psycopg2:
        try:
            cls._connection = psycopg2.connect(
                database=cls._db_name,
                user=cls._db_user,
                password=cls._user_password,
                host=cls._db_host,
                port=cls._db_port,
            )
        except psycopg2.OperationalError as ex:
            print(f'the operational error:\n{ex}')
        except BaseException as ex:
            print(f'other error:\n{ex}')
        else:
            print("connection to PostgreSQL DB successful")
        return cls._connection


    # insert / update / delete
    @classmethod
    def execute_query(cls, query: str) -> bool:
        if cls._connection is None:
            cls._connect()
        cls._connection.autocommit = True
        cursor = cls._connection.cursor()
        try:
            cursor.execute(query)
        except psycopg2.OperationalError as ex:
            print(f'the operational error:\n{ex}')
        except BaseException as ex:
            print(f'the error:\n{ex}')
        else:
            print('the query executed successfully')
            return True
        return False


    # select
    @classmethod
    def select_query(cls, query: str) -> list:
        if cls._connection is None:
            cls._connect()
        cls._connection.autocommit = True
        cursor = cls._connection.cursor()
        try:
            cursor.execute(query)
            result = cursor.fetchall()
        except psycopg2.OperationalError as ex:
            print(f'the operational error:\n{ex}')
        except BaseException as ex:
            print(f'the error:\n{ex}')
        else:
            print('the select query is successfully')
            return result
        return None




class Table(ABC):
    '''
    класс описывающий сущность/таблицу в базе
    является абстрактным
    и содержит минимальный набор методов, необходимый для реализации:
    это методы
    - add - добавления записи о сущности в базу
    - get - получения обекта сущности, в соответсвии с идентификатором (и значениями из базы)
    '''
    name = 'table'
    columns: list[str]
    create_script = ''
    # insert_query.format('table_name', 'columns...', values: tuple)
    _insert_query = '''
    INSERT INTO {}
    ( {} )
    VALUES
    {}
    ;
    '''

    _get_query = '''
    SELECT *
    FROM {}
    WHERE id = {}
    ;
    '''

    @classmethod
    @abstractmethod
    def add(cls, obj: object):
        pass

    @classmethod
    @abstractmethod
    def get_by_id(cls, id: int):
        pass


class User(UserMixin):
    '''
    класс пользователя
    описывает пользователя как класс
    '''
    def __init__(self,
                 id: int = 0,
                 username: str = '',
                 email: str = '',
                 password_hash: str = ''):
        self.id: int = id
        self.username: str = username
        self.email: str = email
        self.password_hash: str = password_hash


    def __repr__(self):
        return f'<User {self.username}>'


    def set_password(self, password: str):
        self.password_hash = generate_password_hash(password)


    def check_password(self, password):
        return check_password_hash(self.password_hash, password)


    def tup(self):
        return (self.username,
                self.email,
                self.password_hash,)


class Users(Table):
    '''
    класс описывающий сущность пользователя, т.е.
    таблицу с пользователями в бд
    а также данный класс инкапсулирует в себе всё взаимодействие с бд
    '''
    name = 'users'
    columns = [
        'username',
        'email',
        'password_hash',
    ]
    create_script = '''
CREATE TABLE IF NOT EXISTS users(
    id      INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    username        VARCHAR(64),
    email           VARCHAR(120),
    password_hash   VARCHAR(128),
    UNIQUE (username)
);
    '''

    @classmethod
    def add(cls, user: User) -> bool:
        query = cls._insert_query.format(cls.name, ', '.join(cls.columns), user.tup())
        return _DataBase.execute_query(query)


    @classmethod
    def get_by_id(cls, id: int) -> User:
        query = cls._get_query.format(cls.name, id)
        res = _DataBase.select_query(query)
        if res is None or len(res) == 0:
            return None
        params = res[0]
        return User(* params)


    @ classmethod
    def get_by_username(cls, username: str):
        query = '''
        SELECT * 
        FROM {}
        WHERE username = '{}'
        ;
        '''.format(cls.name, username)
        res = _DataBase.select_query(query)
        if res is None or len(res) == 0:
            return None
        params = res[0]
        return User(* params)


    @classmethod
    def get_by_email(cls, email: str):
        query = '''
        SELECT * 
        FROM {}
        WHERE email = '{}'
        ;
        '''.format(cls.name, email)
        res = _DataBase.select_query(query)
        if res is None or len(res) == 0:
            return None
        params = res[0]
        return User(* params)


class Follows(Table):
    ''''
    класс описывающий сущности подписок (взаимосвязей)
    - явл. дополнительной таблице для реализации связи многие-ко-многим
    для таблицы Users с самой собой
    '''
    '''
    ***надо дополнить не написаны cascade
    CREATE TABLE follows(
    follower_id
    INT REFERENCES users(id),
    followed_id INT REFERENCES users(id),
    PRIMARY KEY (follower_id, followed_id),
    CHECK (followed_id <> follower_id) )
    ;
    '''

    name = 'follows'
    columns = ['follower_id', 'followed_id']
    @classmethod
    def add(cls, follower_id: int, followed_id: int):
        query = cls._insert_query.format(cls.name, ', '.join(cls.columns), (follower_id, followed_id))
        return _DataBase.execute_query(query)

    '''так как данная таблица реализует связь двух записей таблицы users
    не имеет смысла создавать запрос на выборку по ключу так как каждый кортеж в данной таблице уникален
    логичнее определить метод возвращающий все связи для User`а с конкртетным ID
    данную функцию и будет выполнять данное переопределение метода'''
    @classmethod
    def get_by_id(cls, id: int) -> list[(int, int)]:
        query = '''
            SELECT *
            FROM {}
            WHERE {} = {}
            ;
        '''.format(cls.name, cls.columns[0],  id)
        res = _DataBase.select_query(query)
        if res is None or len(res) == 0:
            return None
        return res


    @classmethod
    def delete_follow(cls, follower_id: int, followed_id: int) -> bool:
        query = '''
            DELETE
            FROM {}
            WHERE {} = {}
            AND {} = {}
            ;
        '''.format(cls.name, cls.columns[0], follower_id, cls.columns[1], followed_id)
        # тут надло выполнить запрос

        return


@login.user_loader
def load_user(id: str):
    user: User = Users.get_by_id(int(id))
    return user
